11 % 9 = 2;
a % b = a - a / b * b;
-10 % -3 = -10 - (-10) / (-3) * (-3) = -1;

++a; --a 自加減してから代入します
a = 2; b = ++a; -> a = 3; b = 3;
a = 2; b = --a; -> a = 1; b = 1;

a++; a-- 代入してから自加減します
a = 2; b = a++; -> a = 3; b = 2;
a = 2; b = a--; -> a = 1; b = 2;

同様に
if(++a == xx);　自加減してから判断します
if(a++ == xx);　判断してから自加減します

除法の時、注意しなければなりません。
System.out.println(10 / 4); -> 2; データ種別の原因です
double d = 10 / 4; -> 2.0

正しい方法
System.out.println(10.0 / 4); -> 2.5

関係演算子:
==; !=; >=; <=; >; <;
instanceof; このClassのObjectかどうか

ロジック演算子：
a && b		and			部分判断
a & b		and			全部判断
a || b			or				部分判断
a | b 		or				全部判断		
!a 			not
a ^ b		a,bは違う

if(y = xx); 条件は代入のとき、結果は「y = xx」を代入してから、「y == True」を判断します

複合演算子
a += b; a = a + b;
-=; *=; /=; %=; 同じ
注意、複合演算子と自加減演算子は自動的に強制データ種別を変えます。例えば：
byte b = 3;
b += 2; -> b = (byte)(b + 2);
b ++; -> b = (byte)(b + 1);

三項演算子
int y = [condition] ? [true do] : [false do];

命名規則と標準
規則：
26個英語字母、数字0-9、_、$に組み合わせます
数字を始めるのはダメです
Javaのキーワードと同じ名前は使用できません
スペースキーもダメです

標準：
packageの名前は全部小文字と点で組み合わせます。aa.bb.cc
class,APIの名前は「AaaBbbCcc」
変数、メソッドの名前は「aaaBbbCcc」、最初の字母は大文字ではありません
定数の名前は「AAA_BBB_CCC」、全部大文字＋_ です

Input操作：
import java.util.Scanner;
Scanner XX = new Scanner(System.in);

String name = XX.next();
XX.nextInt()	XX.nextDouble()	XX.nextBoolean()...

2進数:「0b」を始め 0b1010
8進数:「0」を始め 01010
16進数:「0x」を始め 0x10101 A10 B11 C12 D13 E15

M進数を10進数に転換：∑Ki*M^(i-1) 最も右側に i=1
10進数をM進数に転換：Y / M ＝0までサイクルで、余りを逆します。例えば、34 -> 2進数：
34 / 2 = 17 , mod 0
17 / 2 = 8 . mod 1
8 / 2 = 4 , mod 0
4 / 2 = 2 , mod 0
2 / 2 = 1 , mod 0
1 / 2 = 0 , mod 1
だから[0b100010]

2進数を8進数に転換：右側から、三桁代おきに8進数に転換
0b11010101 -> (11)(010)(101) -> (3)(2)(5) -> 0325

2進数を16進数に転換：右側から、四桁代おきにで16進数に転換
0b11010101 -> (1101)(0101) -> (13)(5) -> 0xD5

8進数を2進数に転換：8進数の各数字は三桁代の2進数に転換
0237 -> (2)(3)(7) -> (010)(011)(111) -> 0b010011111

16進数を2進数に転換：16進数の各数字は四桁代の2進数に転換
0x23B -> (2)(3)(11) -> (0010)(0011)(1011) -> 0b001000111011

変位演算子
int a = 1 >> 2; 右に2ビットシフトします
