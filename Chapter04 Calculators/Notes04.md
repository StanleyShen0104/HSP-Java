11 % 9 = 2;
a % b = a - a / b * b;
-10 % -3 = -10 - (-10) / (-3) * (-3) = -1;

++a; --a 自加減してから代入します
a = 2; b = ++a; -> a = 3; b = 3;
a = 2; b = --a; -> a = 1; b = 1;

a++; a-- 代入してから自加減します
a = 2; b = a++; -> a = 3; b = 2;
a = 2; b = a--; -> a = 1; b = 2;

同様に
if(++a == xx);　自加減してから判断します
if(a++ == xx);　判断してから自加減します

除法の時、注意しなければなりません。
System.out.println(10 / 4); -> 2; データ種別の原因です
double d = 10 / 4; -> 2.0

正しい方法
System.out.println(10.0 / 4); -> 2.5

関係演算子:
==; !=; >=; <=; >; <;
instanceof; このClassのObjectかどうか

ロジック演算子：
a && b		and			部分判断
a &  b		and			全部判断
a || b		or			部分判断
a |  b 		or			全部判断		
!a 			not
a ^  b		a,bは違う

if(y = xx); 条件は代入のとき、結果は「y = xx」を代入してから、「y == True」を判断します

複合演算子
a += b; a = a + b;
-=; *=; /=; %=; 同じ
注意、複合演算子と自加減演算子は自動的に強制データ種別を変えます。例えば：
byte b = 3;
b += 2; -> b = (byte)(b + 2);
b ++; -> b = (byte)(b + 1);

三項演算子
int y = [condition] ? [true do] : [false do];